\documentclass[12pt]{beamer}
%\usecolortheme{seagull}
%\usecolortheme{wolverine} yuk
%\usecolortheme{beetle}
\usecolortheme{dove} % black on white
\usepackage[T1]{fontenc}
\usepackage{garamond}
\usefonttheme{serif}
\usepackage{multicol}
\usepackage{pifont}
\usepackage{etex}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{amssymb}
\usepackage{semantic}
\usepackage[all]{xy}
\usepackage{color}
\usepackage{listings}
\usepackage{fancybox}
\usepackage{stmaryrd}
\usepackage{rotating}
\usepackage{wasysym}
\usepackage{ulem}
\usepackage{newunicodechar}
\newunicodechar{‚ä¢}{\ensuremath{\vdash}}
\newunicodechar{‚äß}{\ensuremath{\models}}
\newunicodechar{·µí}{\ensuremath{^\circ}}
\newunicodechar{‚ñ∑}{\ensuremath{\rhd}}
\newunicodechar{Œì}{\ensuremath{\Gamma}}
\newunicodechar{œÉ}{\ensuremath{\sigma}}
\newunicodechar{Œº}{\ensuremath{\mu}}
\newunicodechar{Œª}{\ensuremath{\lambda}}
\newunicodechar{œï}{\ensuremath{\phi}}
\newunicodechar{œà}{\ensuremath{\psi}}
\newunicodechar{‚¶â}{\ensuremath{\llparenthesis}} % Z notation...
\newunicodechar{‚¶ä}{\ensuremath{\rrparenthesis}} % Z notation...
\newunicodechar{‚Üë}{\ensuremath{\uparrow}}
\newunicodechar{‚Üì}{\ensuremath{\downarrow}}
\newunicodechar{‚Üí}{\ensuremath{\rightarrow}}
\newunicodechar{‚áí}{\ensuremath{\Rightarrow}}
\newunicodechar{‚àÄ}{\ensuremath{\mathnormal\forall}}
\newunicodechar{‚àÉ}{\ensuremath{\exists}}
\newunicodechar{‚Ñï}{\ensuremath{\mathbb{N}}}
\newunicodechar{ùîπ}{\ensuremath{\mathbb{B}}}

\usepackage{enumitem}
\setitemize{label=\usebeamerfont*{itemize item}%
  \usebeamercolor[fg]{itemize item}
  \usebeamertemplate{itemize item}}
  \setlist{itemsep=1ex}



\newcommand{\Gbox}[1]{\colorbox{lightgray}{#1}}
\newcommand{\Rbox}[1]{\colorbox{pink}{#1}}

\newcommand{\featstart}{\hfill}
\newcommand{\featend}{\hfill\hfill}
\newcommand{\feat}[1]{{\featstart#1\featend}}

\newcommand{\Topcircle}{\begin{turn}{270}\Leftcircle\end{turn}}
\newcommand{\BOTTOMCIRCLE}{\begin{turn}{270}\RIGHTCIRCLE\end{turn}}
\newcommand{\halfcircle}{\parbox{0in}{\Topcircle}\parbox{1.65ex}{\BOTTOMCIRCLE}{}}

\newcommand{\featY}{\feat{\CIRCLE}} % Has feature fully
\newcommand{\featP}{\feat{\halfcircle}} % Has feature partially
\newcommand{\featN}{\feat{\Circle}} % Does not have feature


\newcommand{\labeltag}[1]{\label{#1}\tag{\textsc{#1}}}
\newcommand{\type}{\vdash}
\newcommand{\typeS}{\vdash_{STLC}}
\newcommand{\typeG}{\vdash}
\newcommand{\typeCC}{\vdash_{C}}

\newcommand{\evall}{\Downarrow }
\newcommand{\evallS}{\Downarrow_{STLC} }
\newcommand{\evallG}{\Downarrow}
\newcommand{\evallCC}{\Downarrow_{C}}
\newcommand{\evallD}{\Downarrow_{DTLC}}

\newcommand{\reduce}{\longrightarrow}
\newcommand{\becomes}{\longrightarrow}

\newcommand{\EE}{{\cal E}}
\newcommand{\FF}{{\cal F}}
\newcommand{\Hole}{\Box}

\newcommand{\divergeG}{\Uparrow}
\newcommand{\subtype}{<:}
\newcommand{\consis}{\sim}

\newcommand{\embed}[1]{\lceil #1 \rceil}
\newcommand{\bl}[1]{{\color{blue} #1}}
\newcommand{\rd}[1]{{\color{red} #1}}
\newcommand{\pr}[1]{{\color{purple} #1}}
\newcommand{\gr}[1]{{\color{green} #1}}
\newcommand{\kw}[1]{\mathtt{#1}}

\newcommand{\labels}[1]{\mathit{labels}(#1)}
\newcommand{\static}[2]{\mathit{static}(#1,#2)}
\newcommand{\safe}[1]{\mathrel{\mathit{safe}} #1}
\newcommand{\lo}[1]{\overline{#1}}
\newcommand{\rng}[1]{\mathit{rng}(#1)}

\newcommand{\semi}{\mathbin{;}}
\newcommand{\id}{\key{id}}
\newcommand{\Id}[1]{\id_{#1}}
\newcommand{\fail}[3]{\bot^{#1}_{#2 \Rightarrow #3}}
\newcommand{\Fail}[1]{\bot^{#1}}
\newcommand{\FAIL}[3]{\bot^{#2}}
\newcommand{\qu}[2]{{{#2}\query^{#1}}}
\newcommand{\pl}[1]{{#1\pling}}
\newcommand{\query}{\mathtt{?}}
\newcommand{\pling}{\mathtt{!}}

\newcommand{\bcfun}[1]{\langle\!\langle #1 \rangle\!\rangle}
\newcommand{\MergeT}{\sqcap}
\newcommand{\RefC}[1]{\key{Ref}(#1)}
\newcommand{\error}{\key{error}}
\newcommand{\rtti}[2]{#1(#2)_{\mathsf{rtti}}}
\newcommand{\val}[2]{#1(#2)_{\mathsf{val}}}

\newcommand{\Obj}{\key{Obj}}
\newcommand{\String}{\key{String}}
\newcommand{\Double}{\key{Double}}

\newcommand{\OR}{\mathop{\mathsf{or}·µí}}
\newcommand{\AND}{\mathop{\mathsf{and}·µí}}
\newcommand{\EX}{\mathop{‚àÉ·µí}}
\newcommand{\ALL}{\mathop{‚àÄ·µí}}

%\newcommand{\If}[3]{\key{if}\,#1\key{if}\,#2\key{if}#3}


\newcommand{\ba}{\begin{array}}
\newcommand{\ea}{\end{array}}
\newenvironment{stack}{\ba{@{}l@{}}}{\ea}
\newenvironment{branch}{\left\{\ba{@{}l@{\qquad}l@{}}}{\ea\right\}}
\newenvironment{syntax}{\[\ba{l@{\;\;}lcl}}{\ea\]}
\newcommand{\dotspace}{.\,}
\newcommand{\key}[1]{\ensuremath{\mathtt{#1}}}
\newcommand{\Base}{B}
\newcommand{\dyn}{\star}
\newcommand{\Dyn}{\ensuremath{\star}}
\newcommand{\Int}{\key{Int}}
\newcommand{\Nat}{\mathbb{N}}
\newcommand{\Float}{\key{float}}
\newcommand{\Bool}{\key{Bool}}
\newcommand{\Str}{\key{String}}
%\newcommand{\Ref}{\key{Ref}\,}
\newcommand{\lam}[1]{\lambda #1}
\newcommand{\Lam}[1]{\Lambda #1 \dotspace}
\newcommand{\by}{\mapsto}
\newcommand{\app}{\;\,}
\newcommand{\tapp}{\;\,}
\newcommand{\of}{{:}}
\newcommand{\tu}{{\to}}
\newcommand{\To}{\Rightarrow}
\newcommand{\Let}{\key{let}\;}
\newcommand{\Letrec}{\key{let}\,\key{rec}\;}
\newcommand{\In}{\key{in}\;}
\newcommand{\If}{\key{if}\;}
\newcommand{\Then}{\;\key{then}\;}
\newcommand{\Else}{\;\key{else}\;}
\newcommand{\True}{\key{true}}
\newcommand{\False}{\key{false}}
\newcommand{\zero}{\key{zero}}
\newcommand{\suc}[1]{\key{suc}(#1)}
\newcommand{\as}{\mathrel{\key{as}}}
\newcommand{\op}{\mathit{op}}
\newcommand{\dom}[1]{\mathit{dom}(#1)}
\newcommand{\cod}[1]{\mathit{cod}(#1)}
\newcommand{\blame}[1]{\key{blame}\,#1}
\newcommand{\pblame}[2]{\key{blame}\,#1@#2}
\newcommand{\ledyn}{\sqsubseteq}
\newcommand{\IS}{\mathrel{\mathtt{is}}}
\newcommand{\cast}[1]{\overset{#1}{\Rightarrow}}
%\newcommand{\mkcast}[1]{\langle\!\langle#1\rangle\!\rangle}
\newcommand{\mkcast}[1]{(#1)}
\newcommand{\alloc}{\key{ref}\,}
\newcommand{\deref}{\texttt{!}}
\newcommand{\update}{\mathrel{\texttt{:=}}}
\newcommand{\all}[1]{\forall #1.\,}
\newcommand{\ftv}[1]{\mathrm{ftv}(#1)}
\newcommand{\CAST}[1]{\langle #1 \rangle}
\newcommand{\new}[1]{\nu #1.\;}
\newcommand{\case}[3]{\key{case}\,#1\,#2\,#3}
\newcommand{\join}[2]{#1 \sqcup #2 }
\newcommand{\meet}[2]{#1 \sqcap #2 }

\newcommand*\oldmacro{}%
\let\oldmacro\insertshorttitle%
\renewcommand*\insertshorttitle{%
  \oldmacro\hfill%
  \insertframenumber\,/\,\inserttotalframenumber}

\setbeamertemplate{navigation symbols}{}
\setbeamertemplate{footline}[frame number]

%\newtheorem{definition}{Definition}
\newtheorem{conjecture}[theorem]{\translate{Conjecture}}
\newtheorem{proposition}[theorem]{\translate{Proposition}}

\lstdefinestyle{basic}{
%showstringspaces=false,
language=Python,
columns=fullflexible,
%basicstyle=\sffamily\small,%
basicstyle=\ttfamily,%
%columns=fixed,
%basewidth=0.49em,
%lineskip=0pt,
%escapechar=@,xleftmargin=1pc,%
keywordstyle=\ttfamily,
mathescape=true,%
moredelim=**[is][\color{blue}]{@}{@},
moredelim=[is][\color{red}]{|}{|},
moredelim=[is][\color{blue}]{~}{~},
%commentstyle=\rmfamily,%
%morekeywords={return,fix,var,proc,fun,func},%
%deletekeywords={int,bool}
}
\lstset{style=basic}

\garamond

\title[Type Safety via Step-Index Logic]{Intro. to Step-Indexed Logical Relations: Type Safety for STLC + fix}
\author{Jeremy G. Siek \\[1ex]
 Indiana University, Bloomington
}
\date{}
%% \institute{\normalsize 
%%  Indiana University, Bloomington
%% }

% 3 hours

%\newcommand\footnotemark{}
%\renewcommand\footnoterule{}
\setbeamercolor{footnote mark}{fg=white}

\begin{document}

%===============================================================================
\frame{
\titlepage

\vspace{-40pt}
\begin{tabular}{ccc}
\begin{minipage}{0.2\textwidth}
  %\includegraphics[height=2in]{knight}
  %image
  \ 
\end{minipage}
&
\begin{minipage}{0.45\textwidth}
\begin{center}
PL Wonks \\
November 2023 \\
\ \\
\ \\
\ \\
\ \\
\end{center}
\end{minipage}
&
\begin{minipage}{0.2\textwidth}
  %\includegraphics[height=2in]{peltast}
  %image
  \ 
\end{minipage}
\end{tabular}

}
%===============================================================================
\frame{
\frametitle{Outline}

\begin{itemize}
\item Review of
  \begin{itemize}
    \item STLC + fix
    \item Type Safety via Progress and Preservation
  \end{itemize}
\item The Logical Relations Recipe
\item Strawman Logical Relation for Type Safety
\item Step-indexed Logical Relation for Type Safety
\item A Step-indexed Logic
\item Proof of the Fundamental Lemma
  \begin{itemize}  
  \item Proof of the Bind Lemma
  \item Proof of the Compatibility Lemmas
  \end{itemize}
\item Proof of Type Safety
\end{itemize}

}
%===============================================================================
\frame{
\frametitle{Review: STLC + fix}

\[
\begin{array}{llcl}
\text{types} & A,B &::=& \Nat \mid A \to B \\
\text{terms} & L,M,N &::= & \zero \mid \suc{M} \mid \case{L}{M}{N} \mid \\
  &&& i \mid \lam{N} \mid L \app M
      \mid \mu N \\
\text{values} & V,W & ::= & \zero \mid \suc{V} \mid \lam{N} \mid \mu V \\
\text{frames} & F & ::= & \suc{\Box} \mid \case{\Box}{M}{N}
  \mid \Box \app M \mid V \app \Box
\end{array}
\]
Substitution: $\qquad N[M]$  \\
$\qquad${\footnotesize (In $N$, replace variable $0$ with $M$ and decrement
 all free variables.)} \\

Reduction
\begin{align*}
  (\mu V) \app W &\longrightarrow V[\mu V] \app W \\
  (\lam{N}) \app W &\longrightarrow N[W]\\
  \case{\zero}{M}{N} &\longrightarrow M \\
  \case{\suc{V}}{M}{N} &\longrightarrow N[V] \\
  F ‚¶â M ‚¶ä &\longrightarrow F ‚¶â N ‚¶ä & \text{if } M \longrightarrow N
\end{align*}

}
%===============================================================================
\frame{
\frametitle{Review: STLC + fix}

\fbox{$\Gamma \vdash^\mathcal{V} V : A$}
\begin{gather*}
  \inference{}
            {\Gamma \vdash^\mathcal{V} \zero : \Nat}
            \quad
  \inference{\Gamma \vdash^\mathcal{V} V : \Nat}
            {\Gamma \vdash^\mathcal{V} \suc{V} : \Nat}
            \\[2ex]
  \inference{\Gamma,A \vdash^\mathcal{V} N : B}{\Gamma \vdash^\mathcal{V} \lam{N} : A \to B}
  \inference{\Gamma,A \to B \vdash^\mathcal{V} V : A \to B}{\Gamma \vdash^\mathcal{V} \mu{V} : A \to B}
\end{gather*}

\fbox{$\Gamma \vdash M : A$}
\begin{gather*}
  \inference{\Gamma \vdash^{\mathcal{V}} V : A}{\Gamma \vdash V : A}
  \quad
  \inference{}
            {Œì \vdash i : Œì_i}
            \\[2ex]
  \inference{\Gamma \vdash L : A \to B & \Gamma \vdash M : A}
            {\Gamma \vdash L \app M : B}
            \\[1ex]
  \inference{\Gamma \vdash M : \Nat}
            {\Gamma \vdash \suc{M} : \Nat}
  \quad
            \inference{\Gamma \vdash L : \Nat \\
              \Gamma \vdash M : A &
              \Nat,\Gamma \vdash N : A}
                      {\Gamma \vdash \case{L}{M}{N} : A}
\end{gather*}

}

%===============================================================================
\frame{
  \frametitle{Review: Type Safety via Progress \& Preservation}

  \begin{lemma}[Progress]
    If $\Gamma \vdash M : A$ then either
    $M$ is a value or
    $M \longrightarrow N$ for some $N$.
  \end{lemma}

  \begin{lemma}[Presevation]
    If $\Gamma \vdash M : A$ and $M \longrightarrow N$ then
    $\Gamma \vdash N : A$.
  \end{lemma}

  \begin{theorem}[Type Safety]
    If $\;\vdash M : A$ then either
    $M \longrightarrow^{*} V$ for some $V$
    or $M$ diverges.
  \end{theorem}

}

%===============================================================================
\frame{
  \frametitle{Aside: de Bruijn variables and substitutions}

  A substitution $\sigma$ is a mapping of variables to terms. \\[1ex]

  We use de Bruijn variables, so they are numbers: $0, 1, 2, \ldots$ \\[1ex]
  
  We represent a substitution as a sequence of terms:
  \[
  \sigma = M_0, M_1, M_2, \ldots
  \]
  Applying a substitution to a term: \fbox{$œÉ(M)$}
  {\small
  \begin{align*}
    œÉ(\zero) &=  \zero \\
    œÉ(\suc{M}) &=  \suc{œÉ(M)} \\
    œÉ(\case{L}{M}{N}) &= \case{œÉ(L)}{œÉ(M)}{\mathsf{ext}(œÉ)(N)}\\
      & \text{where  } \mathsf{ext}(œÉ) = 0, ‚Üë œÉ_0, ‚Üë œÉ_1, ‚Ä¶ \\
    œÉ(i) &= œÉ_i \\
    œÉ(\lam{N}) &= \lam{\,\mathsf{ext}(œÉ)(N)} \\
    œÉ(L \app M) &= œÉ(L) \app œÉ(M) \\
    œÉ(Œº N) &= Œº \,\mathsf{ext}(œÉ)(N)
  \end{align*}
  }  
}

%===============================================================================
\frame{
  \frametitle{The Logical Relations Recipe}

  \begin{itemize}
  \item Define two functions that generalize the theorem you'd like to
    prove: one maps types to a predicate on closed values $\mathcal{V}(A)(V)$
    and the other maps types to a predicate on closed terms $\mathcal{E}(A)(M)$.
  \item Extend the $\mathcal{V}$ and $\mathcal{E}$ functions to open terms:
    \begin{align*}
      \mathcal{G}(\Gamma)(\sigma) &=
        \forall A_i \in \Gamma, \mathcal{V}(A_i)(\sigma_i)  \\
        \Gamma \models^{\mathcal{V}} V : A &=
           \forall \sigma,
           \mathcal{G}(\Gamma)(\sigma) \text{ implies }
           \mathcal{V}(A)(\sigma(V)) \\
        \Gamma \models M : A &=
           \forall \sigma,
           \mathcal{G}(\Gamma)(\sigma) \text{ implies }
           \mathcal{E}(A)(\sigma(M))
    \end{align*}
    
  \item Prove the Fundamental Lemma, that\\
    (1) $\Gamma \vdash^{\mathcal{V}} V : A$ implies $\Gamma \models^{\mathcal{V}} V : A$ and\\
    (2) $\Gamma \vdash M : A$ implies $\Gamma \models M : A$.

  \item Prove that $\mathcal{E}(A)(M)$ implies your theorem.
    
  \end{itemize}
}  

%===============================================================================
\frame{
  \frametitle{Strawman Logical Relation for Type Safety}

  \fbox{$\mathcal{E}(A)(M) : ùîπ$} \qquad  ``Progress and Preservation''
  \[
  \mathcal{E}(A)(M) = 
  \begin{array}{l}
    \mathcal{V}(A)(M) \mathop{\mathsf{or}} ‚àÉ M', M \longrightarrow M' \\
    \mathop{\mathsf{and}} ‚àÄ M', M \longrightarrow M' \Rightarrow \mathcal{E}(A)(M')
  \end{array}
  \]
  \fbox{$\mathcal{V}(A)(V) : ùîπ$}
  \begin{align*}
    \mathcal{V}(\Nat)(\zero) &= \mathsf{true} \\
    \mathcal{V}(\Nat)(\suc{V}) &= \mathcal{V}(\Nat)(V) \\
    \mathcal{V}(A ‚Üí B)(\lam{N}) &= 
      \forall W, \mathcal{V}(A)(W) \Rightarrow \mathcal{E}(B)(N[W]) \\
    \mathcal{V}(A ‚Üí B)(Œº V) &= \mathcal{V}(\rd{A ‚Üí B})(V[Œº V]) \\
    \mathcal{V}(A)(V) &= \mathsf{false} \qquad \text{otherwise} 
  \end{align*}
  \footnote{\rd{Argument of recursion is not smaller.}}
}
%===============================================================================
\frame{
  \frametitle{Step-indexed Logical Relation for Type Safety}
  \fbox{$\mathcal{E}(A)(M) : ‚Ñï ‚Üí ùîπ$}
  \[
  \mathcal{E}(A)(M) = 
  \begin{array}{l}
    \mathcal{V}(A)(M) \OR \EX M', M \longrightarrow M' \\
    \AND \ALL M', M \longrightarrow M' \Rightarrow·µí \mathop{‚ñ∑·µí} \mathcal{E}(A)(M')
  \end{array}
  \]
  \fbox{$\mathcal{V}(A)(V) : ‚Ñï ‚Üí ùîπ$}
  \begin{align*}
    \mathcal{V}(\Nat)(\zero) &= \mathsf{true}·µí \\
    \mathcal{V}(\Nat)(\suc{V}) &= \mathcal{V}(\Nat)(V) \\
    \mathcal{V}(A ‚Üí B)(\lam{N}) &= 
      \forall·µí W, \mathop{‚ñ∑·µí} \mathcal{V}(A)(W) \Rightarrow·µí \mathop{‚ñ∑·µí} \mathcal{E}(B)(N[W]) \\
    \mathcal{V}(A ‚Üí B)(Œº V) &= \mathop{‚ñ∑·µí} \mathcal{V}(A ‚Üí B)(V[Œº V]) \\
    \mathcal{V}(A)(V) &= \mathsf{false}·µí \qquad \text{otherwise} 
  \end{align*}
  The $\mathcal{E}$ and $\mathcal{V}$ functions terminate because the
  step-index gets smaller in the recursive calls thanks to ‚ñ∑·µí.

}
%===============================================================================
\frame{
  \frametitle{A Step-indexed Logic}

  \fbox{$œï,œà : ‚Ñï ‚Üí ùîπ$}
  \begin{align*}
    \mathsf{true}·µí(k) &= \mathsf{true} \\
    \mathsf{false}·µí(k) &= \mathsf{false} \\
    (œï \AND œà)(k) &=  œï(k) \text{ and } œà(k) \\
    (‚àÄx, P(x))(k) &=  ‚àÄx, P(x)(k) \\
    (\mathop{‚ñ∑·µí} œï)(k) &= ‚àÄ j, j < k ‚áí œï(j) \\
    \vdots
  \end{align*}

  \fbox{$œà_1,\ldots,œà_n ‚ä¢·µí œï$}
  \[
  œà_1,\ldots,œà_n ‚ä¢·µí œï \quad=\quad
    ‚àÄ k, œà_1(k) \text{ and } \cdots\; œà_n(k) ‚áí œï(k)
  \] 
  
}

%===============================================================================
\frame{
  \frametitle{Recipe: extend $\mathcal{V}$ and $\mathcal{E}$ to open terms}

    \begin{align*}
      \mathcal{G}(A_1,\ldots,A_n)(\sigma) &=
         \mathcal{V}(A_1)(\sigma_0), \ldots, \mathcal{V}(A_n)(\sigma_n)   \\
      \Gamma \models^{\mathcal{V}} V : A &=
        \forall \sigma,
        \mathcal{G}(\Gamma)(\sigma) \mathop{‚ä¢·µí} \mathcal{V}(A)(\sigma(V))\\
      \Gamma \models M : A &=
        \forall \sigma,
        \mathcal{G}(\Gamma)(\sigma) \mathop{‚ä¢·µí} \mathcal{E}(A)(\sigma(M))
    \end{align*}
  
}
%===============================================================================
\frame{
  \frametitle{Recipe: prove the Fundamental Lemma}

  \begin{lemma}[Fundamental] \normalfont
    (1) $\Gamma \vdash^{\mathcal{V}} V : A$
        implies $\Gamma \models^{\mathcal{V}} V : A$ and\\
    (2) $\Gamma \vdash M : A$ implies $\Gamma \models M : A$.
  \end{lemma}

  The proof is by mutual induction on $\Gamma \vdash^{\mathcal{V}} V : A$
  and $\Gamma \vdash M : A$.

  By tradition, each case of the proof is proved by a separate lemma.
  These lemmas are called the ``compatibility'' lemmas.

}  
%===============================================================================
\frame{
  \frametitle{Compatibility Lemmas}

  \footnote{Some compatibility lemmas are easy.}
  
  \begin{lemma}[Compatibility for \zero]
    $Œì \models^{\mathcal{V}} \zero : ‚Ñï$.
  \end{lemma}
  \begin{proof}
    Let $œÉ$ be a substitution.
    We need to show that
    \[
    \mathcal{G}(Œì)(œÉ) ‚ä¢·µí \mathcal{V}(‚Ñï)(œÉ(\zero))
    \]
    which is equivalent to 
    \[
    \mathcal{G}(Œì)(œÉ) ‚ä¢·µí \mathsf{true}·µí
    \]
    which is trivially true.
  \end{proof}
}
%===============================================================================
\frame{
  \frametitle{Compatibility Lemmas, continued}

  \begin{lemma}[Compatibility for \suc{V}]
    If $Œì \models^{\mathcal{V}} V : ‚Ñï$,
    then $Œì \models^{\mathcal{V}} \suc{V} : ‚Ñï$.
  \end{lemma}
  \begin{proof}
    Let $œÉ$ be a substitution.
    We need to show that
    \[
    \mathcal{G}(Œì)(œÉ) ‚ä¢·µí \mathcal{V}(‚Ñï)(œÉ(\suc{V}))
    \]
    which is equivalent to 
    \[
    \mathcal{G}(Œì)(œÉ) ‚ä¢·µí \mathcal{V}(‚Ñï)(œÉ(V))
    \]
    which we obtain from the premise.
  \end{proof}
}
%===============================================================================
\frame{
  \frametitle{Compatibility Lemmas, continued}

  \begin{lemma}[Compatibility for $\lam{N}$]
    If $A,Œì \models N : B$,
    then $Œì \models^{\mathcal{V}} \lam{N} : A ‚Üí B$.
  \end{lemma}
  \begin{proof}
    Let $œÉ$ be a substitution.
    We need to show that
    \[
    \mathcal{G}(Œì)(œÉ) ‚ä¢·µí \forall·µí W, \mathop{‚ñ∑·µí} \mathcal{V}(A)(W)
         \Rightarrow·µí \mathop{‚ñ∑·µí} \mathcal{E}(B)(\mathsf{ext}(œÉ)(N)[W])
    \]
    Let $W$ be a value and assume $\mathop{‚ñ∑·µí} \mathcal{V}(A)(W)$.
    From the premise $A,Œì ‚äß N : B$ we have
    $\mathcal{V}(A,W),\mathcal{G}(Œì)(œÉ) ‚ä¢·µí \mathcal{E}(B)((W,œÉ)(N))$
    and therefore
  $\mathcal{G}(Œì)(œÉ) ‚ä¢·µí \mathcal{V}(A,W) \mathop{‚áí·µí} \mathcal{E}(B)((W,œÉ)(N))$.
    With the assumption, we have $\mathop{‚ñ∑·µí} \mathcal{E}(B)((W,œÉ)(N))$.
    We conclude via the following equality
    \begin{align*}
      \mathsf{ext}(œÉ)(N)[W] &= (W, ‚Üì ‚Üë œÉ_0, ‚Üì ‚Üë œÉ_1, ‚Ä¶)(N) \\
                            &=  (W, œÉ)(N)
    \end{align*}
  \end{proof}
}
%===============================================================================
\frame{
  \frametitle{Aside: L\"ob Induction}
  {\Large
  \[
  \inference{‚ñ∑·µí œï, \mathcal{P} ‚ä¢·µí œï}
            {\mathcal{P} ‚ä¢·µí œï}
  \]
  }
  
  \footnote{Equivalent to strong induction on the step index.}
}
%===============================================================================
\frame{
  \frametitle{Compatibility Lemmas, continued}

  \begin{lemma}[Compatibility for $Œº \,V$]
    If $A‚ÜíB,Œì \models^{\mathcal{V}} V : A ‚Üí B$,
    then $Œì \models^{\mathcal{V}} Œº \,V : A ‚Üí B$.
  \end{lemma}
  \begin{proof}

  \end{proof}
}
%===============================================================================
\end{document}
