\documentclass[12pt]{beamer}
%\usecolortheme{seagull}
%\usecolortheme{wolverine} yuk
%\usecolortheme{beetle}
\usecolortheme{dove} % black on white
\usepackage[T1]{fontenc}
\usepackage{garamond}
\usefonttheme{serif}
\usepackage{multicol}
\usepackage{pifont}
\usepackage{etex}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{amssymb}
\usepackage{semantic}
\usepackage[all]{xy}
\usepackage{color}
\usepackage{listings}
\usepackage{fancybox}
\usepackage{stmaryrd}
\usepackage{rotating}
\usepackage{wasysym}
\usepackage{ulem}
\usepackage{newunicodechar}
\newunicodechar{‚àÖ}{\ensuremath{\emptyset}}
\newunicodechar{‚ä¢}{\ensuremath{\vdash}}
\newunicodechar{‚äß}{\ensuremath{\models}}
\newunicodechar{·µí}{\ensuremath{^\circ}}
\newunicodechar{‚ñ∑}{\ensuremath{\rhd}}
\newunicodechar{Œ±}{\ensuremath{\alpha}}
\newunicodechar{Œ≤}{\ensuremath{\beta}}
\newunicodechar{Œì}{\ensuremath{\Gamma}}
\newunicodechar{œÉ}{\ensuremath{\sigma}}
\newunicodechar{Œº}{\ensuremath{\mu}}
\newunicodechar{Œª}{\ensuremath{\lambda}}
\newunicodechar{œï}{\ensuremath{\phi}}
\newunicodechar{œà}{\ensuremath{\psi}}
\newunicodechar{‚¶â}{\ensuremath{\llparenthesis}} % Z notation...
\newunicodechar{‚¶ä}{\ensuremath{\rrparenthesis}} % Z notation...
\newunicodechar{‚Üë}{\ensuremath{\uparrow}}
\newunicodechar{‚Üì}{\ensuremath{\downarrow}}
\newunicodechar{‚Üí}{\ensuremath{\rightarrow}}
\newunicodechar{‚áí}{\ensuremath{\Rightarrow}}
\newunicodechar{‚àÄ}{\ensuremath{\mathnormal\forall}}
\newunicodechar{‚àÉ}{\ensuremath{\exists}}
\newunicodechar{‚Ñï}{\ensuremath{\mathbb{N}}}
\newunicodechar{ùîπ}{\ensuremath{\mathbb{B}}}
\newunicodechar{‚Ñ∞}{\ensuremath{\mathcal{E}}}
\newunicodechar{ùí±}{\ensuremath{\mathcal{V}}}
\newunicodechar{ùí´}{\ensuremath{\mathcal{P}}}

\usepackage{enumitem}
\setitemize{label=\usebeamerfont*{itemize item}%
  \usebeamercolor[fg]{itemize item}
  \usebeamertemplate{itemize item}}
  \setlist{itemsep=1ex}



\newcommand{\Gbox}[1]{\colorbox{lightgray}{#1}}
\newcommand{\Rbox}[1]{\colorbox{pink}{#1}}

\newcommand{\featstart}{\hfill}
\newcommand{\featend}{\hfill\hfill}
\newcommand{\feat}[1]{{\featstart#1\featend}}

\newcommand{\Topcircle}{\begin{turn}{270}\Leftcircle\end{turn}}
\newcommand{\BOTTOMCIRCLE}{\begin{turn}{270}\RIGHTCIRCLE\end{turn}}
\newcommand{\halfcircle}{\parbox{0in}{\Topcircle}\parbox{1.65ex}{\BOTTOMCIRCLE}{}}

\newcommand{\featY}{\feat{\CIRCLE}} % Has feature fully
\newcommand{\featP}{\feat{\halfcircle}} % Has feature partially
\newcommand{\featN}{\feat{\Circle}} % Does not have feature


\newcommand{\labeltag}[1]{\label{#1}\tag{\textsc{#1}}}
\newcommand{\type}{\vdash}
\newcommand{\typeS}{\vdash_{STLC}}
\newcommand{\typeG}{\vdash}
\newcommand{\typeCC}{\vdash_{C}}

\newcommand{\evall}{\Downarrow }
\newcommand{\evallS}{\Downarrow_{STLC} }
\newcommand{\evallG}{\Downarrow}
\newcommand{\evallCC}{\Downarrow_{C}}
\newcommand{\evallD}{\Downarrow_{DTLC}}

\newcommand{\reduce}{\longrightarrow}
\newcommand{\becomes}{\longrightarrow}

\newcommand{\EE}{{\cal E}}
\newcommand{\FF}{{\cal F}}
\newcommand{\Hole}{\Box}

\newcommand{\divergeG}{\Uparrow}
\newcommand{\subtype}{<:}
\newcommand{\consis}{\sim}

\newcommand{\embed}[1]{\lceil #1 \rceil}
\newcommand{\bl}[1]{{\color{blue} #1}}
\newcommand{\rd}[1]{{\color{red} #1}}
\newcommand{\pr}[1]{{\color{purple} #1}}
\newcommand{\gr}[1]{{\color{green} #1}}
\newcommand{\kw}[1]{\mathtt{#1}}

\newcommand{\labels}[1]{\mathit{labels}(#1)}
\newcommand{\static}[2]{\mathit{static}(#1,#2)}
\newcommand{\safe}[1]{\mathrel{\mathit{safe}} #1}
\newcommand{\lo}[1]{\overline{#1}}
\newcommand{\rng}[1]{\mathit{rng}(#1)}

\newcommand{\semi}{\mathbin{;}}
\newcommand{\id}{\key{id}}
\newcommand{\Id}[1]{\id_{#1}}
\newcommand{\fail}[3]{\bot^{#1}_{#2 \Rightarrow #3}}
\newcommand{\Fail}[1]{\bot^{#1}}
\newcommand{\FAIL}[3]{\bot^{#2}}
\newcommand{\qu}[2]{{{#2}\query^{#1}}}
\newcommand{\pl}[1]{{#1\pling}}
\newcommand{\query}{\mathtt{?}}
\newcommand{\pling}{\mathtt{!}}

\newcommand{\bcfun}[1]{\langle\!\langle #1 \rangle\!\rangle}
\newcommand{\MergeT}{\sqcap}
\newcommand{\RefC}[1]{\key{Ref}(#1)}
\newcommand{\error}{\key{error}}
\newcommand{\rtti}[2]{#1(#2)_{\mathsf{rtti}}}
\newcommand{\val}[2]{#1(#2)_{\mathsf{val}}}

\newcommand{\Obj}{\key{Obj}}
\newcommand{\String}{\key{String}}
\newcommand{\Double}{\key{Double}}

\newcommand{\OR}{\mathop{\mathsf{or}·µí}}
\newcommand{\AND}{\mathop{\mathsf{and}·µí}}
\newcommand{\EX}{\mathop{‚àÉ·µí}}
\newcommand{\ALL}{\mathop{‚àÄ·µí}}

%\newcommand{\If}[3]{\key{if}\,#1\key{if}\,#2\key{if}#3}


\newcommand{\ba}{\begin{array}}
\newcommand{\ea}{\end{array}}
\newenvironment{stack}{\ba{@{}l@{}}}{\ea}
\newenvironment{branch}{\left\{\ba{@{}l@{\qquad}l@{}}}{\ea\right\}}
\newenvironment{syntax}{\[\ba{l@{\;\;}lcl}}{\ea\]}
\newcommand{\dotspace}{.\,}
\newcommand{\key}[1]{\ensuremath{\mathtt{#1}}}
\newcommand{\Base}{B}
\newcommand{\dyn}{\star}
\newcommand{\Dyn}{\ensuremath{\star}}
\newcommand{\Int}{\key{Int}}
\newcommand{\Nat}{\mathbb{N}}
\newcommand{\Float}{\key{float}}
\newcommand{\Bool}{\key{Bool}}
\newcommand{\Str}{\key{String}}
%\newcommand{\Ref}{\key{Ref}\,}
\newcommand{\lam}[1]{\lambda #1}
\newcommand{\Lam}[1]{\Lambda #1 \dotspace}
\newcommand{\by}{\mapsto}
\newcommand{\app}{\;\,}
\newcommand{\tapp}{\;\,}
\newcommand{\of}{{:}}
\newcommand{\tu}{{\to}}
\newcommand{\To}{\Rightarrow}
\newcommand{\Let}{\key{let}\;}
\newcommand{\Letrec}{\key{let}\,\key{rec}\;}
\newcommand{\In}{\key{in}\;}
\newcommand{\If}{\key{if}\;}
\newcommand{\Then}{\;\key{then}\;}
\newcommand{\Else}{\;\key{else}\;}
\newcommand{\True}{\key{true}}
\newcommand{\False}{\key{false}}
\newcommand{\zero}{\key{zero}}
\newcommand{\suc}[1]{\key{suc}(#1)}
\newcommand{\as}{\mathrel{\key{as}}}
\newcommand{\op}{\mathit{op}}
\newcommand{\dom}[1]{\mathit{dom}(#1)}
\newcommand{\cod}[1]{\mathit{cod}(#1)}
\newcommand{\blame}[1]{\key{blame}\,#1}
\newcommand{\pblame}[2]{\key{blame}\,#1@#2}
\newcommand{\ledyn}{\sqsubseteq}
\newcommand{\IS}{\mathrel{\mathtt{is}}}
\newcommand{\cast}[1]{\overset{#1}{\Rightarrow}}
%\newcommand{\mkcast}[1]{\langle\!\langle#1\rangle\!\rangle}
\newcommand{\mkcast}[1]{(#1)}
\newcommand{\alloc}{\key{ref}\,}
\newcommand{\deref}{\texttt{!}}
\newcommand{\update}{\mathrel{\texttt{:=}}}
\newcommand{\all}[1]{\forall #1.\,}
\newcommand{\ftv}[1]{\mathrm{ftv}(#1)}
\newcommand{\CAST}[1]{\langle #1 \rangle}
\newcommand{\new}[1]{\nu #1.\;}
\newcommand{\case}[3]{\key{case}\,#1\,#2\,#3}
\newcommand{\join}[2]{#1 \sqcup #2 }
\newcommand{\meet}[2]{#1 \sqcap #2 }

\newcommand*\oldmacro{}%
\let\oldmacro\insertshorttitle%
\renewcommand*\insertshorttitle{%
  \oldmacro\hfill%
  \insertframenumber\,/\,\inserttotalframenumber}

\setbeamertemplate{navigation symbols}{}
\setbeamertemplate{footline}[frame number]

%\newtheorem{definition}{Definition}
\newtheorem{conjecture}[theorem]{\translate{Conjecture}}
\newtheorem{proposition}[theorem]{\translate{Proposition}}

\lstdefinestyle{basic}{
%showstringspaces=false,
language=Python,
columns=fullflexible,
%basicstyle=\sffamily\small,%
basicstyle=\ttfamily,%
%columns=fixed,
%basewidth=0.49em,
%lineskip=0pt,
%escapechar=@,xleftmargin=1pc,%
keywordstyle=\ttfamily,
mathescape=true,%
moredelim=**[is][\color{blue}]{@}{@},
moredelim=[is][\color{red}]{|}{|},
moredelim=[is][\color{blue}]{~}{~},
%commentstyle=\rmfamily,%
%morekeywords={return,fix,var,proc,fun,func},%
%deletekeywords={int,bool}
}
\lstset{style=basic}

\garamond

\title[Type Safety via Step-Index Logic]{Intro. to Step-Indexed Logical Relations: Type Safety for STLC + fix}
\author{Jeremy G. Siek \\[1ex]
 Indiana University, Bloomington
}
\date{}
%% \institute{\normalsize 
%%  Indiana University, Bloomington
%% }

% 3 hours

%\newcommand\footnotemark{}
%\renewcommand\footnoterule{}
\setbeamercolor{footnote mark}{fg=white}

\begin{document}

%===============================================================================
\frame{
\titlepage

\vspace{-40pt}
\begin{tabular}{ccc}
\begin{minipage}{0.2\textwidth}
  %\includegraphics[height=2in]{knight}
  %image
  \ 
\end{minipage}
&
\begin{minipage}{0.45\textwidth}
\begin{center}
PL Wonks \\
November 2023 \\
\ \\
\ \\
\ \\
\ \\
\end{center}
\end{minipage}
&
\begin{minipage}{0.2\textwidth}
  %\includegraphics[height=2in]{peltast}
  %image
  \ 
\end{minipage}
\end{tabular}

}
%===============================================================================
\frame{
\frametitle{Outline}

\begin{itemize}
\item Review of
  \begin{itemize}
    \item STLC + fix
    \item Type Safety via Progress and Preservation
  \end{itemize}
\item The Logical Relations Recipe
\item Strawman Logical Relation for Type Safety
\item Step-indexed Logical Relation for Type Safety
\item A Step-indexed Logic
\item Proof of the Fundamental Lemma
\item Proof of Type Safety
\end{itemize}

}
%===============================================================================
\frame{
\frametitle{Review: STLC + fix}

\[
\begin{array}{llcl}
\text{types} & A,B &::=& \Nat \mid A \to B \\
\text{terms} & L,M,N &::= & \zero \mid \suc{M} \mid \case{L}{M}{N} \mid \\
  &&& i \mid \lam{N} \mid L \app M
      \mid \mu N \\
\text{values} & V,W & ::= & \zero \mid \suc{V} \mid \lam{N} \mid \mu V \\
\text{frames} & F & ::= & \suc{\Box} \mid \case{\Box}{M}{N}
  \mid \Box \app M \mid V \app \Box
\end{array}
\]
Substitution: $\quad N[M]$ \quad{\footnotesize (Replace $0$ with $M$ in $N$, decrement free vars.)} \\
Plug: $\qquad\qquad F ‚¶â M ‚¶ä$ \quad{\footnotesize (Replace $\Box$ with $M$ in $F$.)}

Reduction
\begin{align*}
  (\mu V) \app W &\longrightarrow V[\mu V] \app W \\
  (\lam{N}) \app W &\longrightarrow N[W]\\
  \case{\zero}{M}{N} &\longrightarrow M \\
  \case{\suc{V}}{M}{N} &\longrightarrow N[V] \\
  F ‚¶â M ‚¶ä &\longrightarrow F ‚¶â N ‚¶ä & \text{if } M \longrightarrow N
\end{align*}

}
%===============================================================================
\frame{
\frametitle{Review: STLC + fix}

\fbox{$\Gamma \vdash^ùí± V : A$}
\begin{gather*}
  \inference{}
            {\Gamma \vdash^ùí± \zero : \Nat}
            \quad
  \inference{\Gamma \vdash^ùí± V : \Nat}
            {\Gamma \vdash^ùí± \suc{V} : \Nat}
            \\[2ex]
  \inference{\Gamma,A \vdash^ùí± N : B}{\Gamma \vdash^ùí± \lam{N} : A \to B}
  \inference{\Gamma,A \to B \vdash^ùí± V : A \to B}{\Gamma \vdash^ùí± \mu{V} : A \to B}
\end{gather*}

\fbox{$\Gamma \vdash M : A$}
\begin{gather*}
  \inference{\Gamma \vdash^{ùí±} V : A}{\Gamma \vdash V : A}
  \quad
  \inference{}
            {Œì \vdash i : Œì_i}
            \\[2ex]
  \inference{\Gamma \vdash L : A \to B & \Gamma \vdash M : A}
            {\Gamma \vdash L \app M : B}
            \\[1ex]
  \inference{\Gamma \vdash M : \Nat}
            {\Gamma \vdash \suc{M} : \Nat}
  \quad
            \inference{\Gamma \vdash L : \Nat \\
              \Gamma \vdash M : A &
              \Nat,\Gamma \vdash N : A}
                      {\Gamma \vdash \case{L}{M}{N} : A}
\end{gather*}

}

%===============================================================================
\frame{
  \frametitle{Review: Type Safety via Progress \& Preservation}

  \begin{lemma}[Progress]
    If $\Gamma \vdash M : A$ then either
    $M$ is a value or
    $M \longrightarrow N$ for some $N$.
  \end{lemma}

  \begin{lemma}[Presevation]
    If $\Gamma \vdash M : A$ and $M \longrightarrow N$ then
    $\Gamma \vdash N : A$.
  \end{lemma}

  \begin{theorem}[Type Safety]
    If $\;\vdash M : A$ then either
    $M \longrightarrow^{*} V$ for some $V$
    or $M$ diverges.
  \end{theorem}

}

%===============================================================================
\frame{
  \frametitle{Aside: de Bruijn variables and substitutions}

  A substitution $\sigma$ is a mapping of variables to terms. \\[1ex]

  We use de Bruijn variables, so they are numbers: $0, 1, 2, \ldots$ \\[1ex]
  
  We represent a substitution as a sequence of terms:
  \[
  \sigma = M_0, M_1, M_2, \ldots
  \]
  Applying a substitution to a term: \fbox{$œÉ(M)$}
  {\small
  \begin{align*}
    œÉ(\zero) &=  \zero \\
    œÉ(\suc{M}) &=  \suc{œÉ(M)} \\
    œÉ(\case{L}{M}{N}) &= \case{œÉ(L)}{œÉ(M)}{\mathsf{ext}(œÉ)(N)}\\
      & \text{where  } \mathsf{ext}(œÉ) = 0, ‚Üë œÉ_0, ‚Üë œÉ_1, ‚Ä¶ \\
    œÉ(i) &= œÉ_i \\
    œÉ(\lam{N}) &= \lam{\,\mathsf{ext}(œÉ)(N)} \\
    œÉ(L \app M) &= œÉ(L) \app œÉ(M) \\
    œÉ(Œº N) &= Œº \,\mathsf{ext}(œÉ)(N)
  \end{align*}
  }  
}

%===============================================================================
\frame{
  \frametitle{The Logical Relations Recipe}

  \begin{itemize}
  \item Define two functions that generalize the theorem you'd like to
    prove: one maps types to a predicate on closed values $ùí±(A)(V)$
    and the other maps types to a predicate on closed terms $‚Ñ∞(A)(M)$.
  \item Extend the $ùí±$ and $‚Ñ∞$ functions to open terms:
    \begin{align*}
      \mathcal{G}(\Gamma)(\sigma) &=
        \forall A_i \in \Gamma, ùí±(A_i)(\sigma_i)  \\
        \Gamma \models^{ùí±} V : A &=
           \forall \sigma,
           \mathcal{G}(\Gamma)(\sigma) \text{ implies }
           ùí±(A)(\sigma(V)) \\
        \Gamma \models M : A &=
           \forall \sigma,
           \mathcal{G}(\Gamma)(\sigma) \text{ implies }
           ‚Ñ∞(A)(\sigma(M))
    \end{align*}
    
  \item Prove the Fundamental Lemma, that\\
    (1) $\Gamma \vdash^{ùí±} V : A$ implies $\Gamma \models^{ùí±} V : A$ and\\
    (2) $\Gamma \vdash M : A$ implies $\Gamma \models M : A$.

  \item Prove that $‚Ñ∞(A)(M)$ implies your theorem.
    
  \end{itemize}
}  

%===============================================================================
\frame{
  \frametitle{Strawman Logical Relation for Type Safety}

  \fbox{$‚Ñ∞(A)(M) : ùîπ$} \qquad  ``Progress and Preservation''
  \[
  ‚Ñ∞(A)(M) = 
  \begin{array}{l}
    ùí±(A)(M) \mathop{\mathsf{or}} ‚àÉ M', M \longrightarrow M' \\
    \mathop{\mathsf{and}} ‚àÄ M', M \longrightarrow M' \Rightarrow ‚Ñ∞(A)(M')
  \end{array}
  \]
  \fbox{$ùí±(A)(V) : ùîπ$}
  \begin{align*}
    ùí±(\Nat)(\zero) &= \mathsf{true} \\
    ùí±(\Nat)(\suc{V}) &= ùí±(\Nat)(V) \\
    ùí±(A ‚Üí B)(\lam{N}) &= 
      \forall W, ùí±(A)(W) \Rightarrow ‚Ñ∞(B)(N[W]) \\
    ùí±(A ‚Üí B)(Œº V) &= ùí±(\rd{A ‚Üí B})(V[Œº V]) \\
    ùí±(A)(V) &= \mathsf{false} \qquad \text{otherwise} 
  \end{align*}
  \footnote{\rd{Argument of recursion is not smaller.}}
}
%===============================================================================
\frame{
  \frametitle{Step-indexed Logical Relation for Type Safety}
  \fbox{$‚Ñ∞(A)(M) : ‚Ñï ‚Üí ùîπ$}
  \[
  ‚Ñ∞(A)(M) = 
  \begin{array}{l}
    ùí±(A)(M) \OR \EX M', M \longrightarrow M' \\
    \AND \ALL M', M \longrightarrow M' \Rightarrow·µí \mathop{‚ñ∑·µí} ‚Ñ∞(A)(M')
  \end{array}
  \]
  \fbox{$ùí±(A)(V) : ‚Ñï ‚Üí ùîπ$}
  \begin{align*}
    ùí±(\Nat)(\zero) &= \mathsf{true}·µí \\
    ùí±(\Nat)(\suc{V}) &= ùí±(\Nat)(V) \\
    ùí±(A ‚Üí B)(\lam{N}) &= 
      \forall·µí W, \mathop{‚ñ∑·µí} ùí±(A)(W) \Rightarrow·µí \mathop{‚ñ∑·µí} ‚Ñ∞(B)(N[W]) \\
    ùí±(A ‚Üí B)(Œº V) &= \mathop{‚ñ∑·µí} ùí±(A ‚Üí B)(V[Œº V]) \\
    ùí±(A)(V) &= \mathsf{false}·µí \qquad \text{otherwise} 
  \end{align*}
  The $‚Ñ∞$ and $ùí±$ functions terminate because the
  step-index gets smaller in the recursive calls thanks to ‚ñ∑·µí.

}
%===============================================================================
\frame{
  \frametitle{A Step-indexed Logic (SIL)}

  \fbox{$œï,œà : ‚Ñï ‚Üí ùîπ$}
  \begin{align*}
    \mathsf{true}·µí(k) &= \mathsf{true} \\
    \mathsf{false}·µí(k) &= \mathsf{false} \\
    (œï \AND œà)(k) &=  œï(k) \text{ and } œà(k) \\
    (œï \OR œà)(k) &=  œï(k) \text{ or } œà(k) \\
    (‚àÄx, P(x))(k) &=  ‚àÄx, P(x)(k) \\
    (\mathop{‚ñ∑·µí} œï)(k) &= ‚àÄ j, j < k ‚áí œï(j) \\
    \vdots
  \end{align*}

  \fbox{$œà_1,\ldots,œà_n ‚ä¢·µí œï$}
  \[
  œà_1,\ldots,œà_n ‚ä¢·µí œï \quad=\quad
    ‚àÄ k, œà_1(k) \text{ and } \cdots\; œà_n(k) ‚áí œï(k)
  \] 
  
}

%===============================================================================
\frame{
  \frametitle{A Step-indexed Logic (SIL)}

  Proof rules regarding the ``later`` operator ‚ñ∑·µí:
  \begin{gather*}
    \inference{ùí´ ‚ä¢·µí œï}{ùí´ ‚ä¢·µí ‚ñ∑·µí œï}
    \quad
    \inference{ùí´ ‚ä¢·µí ‚ñ∑·µí (œï ‚áí·µí œà)}
              {ùí´ ‚ä¢·µí ‚ñ∑·µí œï ‚áí·µí ‚ñ∑·µí œà}
    \quad
    \cdots
    \\[1ex]
    \inference{ùí´ ‚ä¢·µí ‚ñ∑·µí œï & œï,ùí´ ‚ä¢·µí œà}
              {ùí´ ‚ä¢·µí ‚ñ∑·µí œà}
  \end{gather*}
  L\"ob Induction:
  \[
  \inference{‚ñ∑·µí œï, ùí´ ‚ä¢·µí œï}
            {ùí´ ‚ä¢·µí œï}
  \]
}  
%===============================================================================
\frame{
  \frametitle{Recipe: extend $ùí±$ and $‚Ñ∞$ to open terms}

    \begin{align*}
      \mathcal{G}(A_1,\ldots,A_n)(\sigma) &=
         ùí±(A_1)(\sigma_0), \ldots, ùí±(A_n)(\sigma_n)   \\
      \Gamma \models^{ùí±} V : A &=
        \forall \sigma,
        \mathcal{G}(\Gamma)(\sigma) \mathop{‚ä¢·µí} ùí±(A)(\sigma(V))\\
      \Gamma \models M : A &=
        \forall \sigma,
        \mathcal{G}(\Gamma)(\sigma) \mathop{‚ä¢·µí} ‚Ñ∞(A)(\sigma(M))
    \end{align*}
  
}
%===============================================================================
\frame{
  \frametitle{Recipe: prove the Fundamental Lemma}

  \begin{lemma}[Fundamental] \normalfont
    (1) $\Gamma \vdash^{ùí±} V : A$
        implies $\Gamma \models^{ùí±} V : A$ and\\
    (2) $\Gamma \vdash M : A$ implies $\Gamma \models M : A$.
  \end{lemma}

  Proceed by mutual induction on $\Gamma \vdash^{ùí±} V : A$
  and $\Gamma \vdash M : A$.

  By tradition, each case of the proof is proved by a separate lemma.
  These lemmas are called the ``compatibility'' lemmas.

}  
%===============================================================================
\frame{
  \frametitle{Compatibility Lemmas}

  \footnote{Some compatibility lemmas are easy.}
  
  \begin{lemma}[Compatibility for \zero]
    $Œì \models^{ùí±} \zero : ‚Ñï$.
  \end{lemma}
  \begin{proof}
    Let $œÉ$ be a substitution.
    We need to show that
    \[
    \mathcal{G}(Œì)(œÉ) ‚ä¢·µí ùí±(‚Ñï)(œÉ(\zero))
    \]
    which is equivalent to 
    \[
    \mathcal{G}(Œì)(œÉ) ‚ä¢·µí \mathsf{true}·µí
    \]
    which is trivial to prove.
  \end{proof}
}
%===============================================================================
\frame{
  \frametitle{Compatibility Lemmas, continued}

  \begin{lemma}[Compatibility for \suc{V}]
    If $Œì \models^{ùí±} V : ‚Ñï$,
    then $Œì \models^{ùí±} \suc{V} : ‚Ñï$.
  \end{lemma}
  \begin{proof}
    Let $œÉ$ be a substitution.
    We need to show that
    \[
    \mathcal{G}(Œì)(œÉ) ‚ä¢·µí ùí±(‚Ñï)(œÉ(\suc{V}))
    \]
    which is equivalent to 
    \[
    \mathcal{G}(Œì)(œÉ) ‚ä¢·µí ùí±(‚Ñï)(œÉ(V))
    \]
    which we obtain from the premise.
  \end{proof}
}
%===============================================================================
\frame{
  \frametitle{Compatibility Lemmas, continued}

  \begin{lemma}[Compatibility for $\lam{N}$]
    If $A,Œì \models N : B$,
    then $Œì \models^{ùí±} \lam{N} : A ‚Üí B$.
  \end{lemma}
  \begin{proof}
    Let $œÉ$ be a substitution.
    We need to show that
    \[
    \mathcal{G}(Œì)(œÉ) ‚ä¢·µí \forall·µí W, \mathop{‚ñ∑·µí} ùí±(A)(W)
         \Rightarrow·µí \mathop{‚ñ∑·µí} ‚Ñ∞(B)(\mathsf{ext}(œÉ)(N)[W])
    \]
    Let $W$ be a value and assume $\mathop{‚ñ∑·µí} ùí±(A)(W)$.\\
    From the premise $A,Œì ‚äß N : B$ we have
    $ùí±(A)(W),\mathcal{G}(Œì)(œÉ) ‚ä¢·µí ‚Ñ∞(B)((W,œÉ)(N))$.\\
    With the assumption, we have $\mathop{‚ñ∑·µí} ‚Ñ∞(B)((W,œÉ)(N))$.
    We conclude via the following equality
    \begin{align*}
      \mathsf{ext}(œÉ)(N)[W] &= (W, ‚Üì ‚Üë œÉ_0, ‚Üì ‚Üë œÉ_1, ‚Ä¶)(N) \\
                            &=  (W, œÉ)(N)
    \end{align*}
  \end{proof}
}
%===============================================================================
\frame{
  \frametitle{Compatibility Lemmas, continued}

  \begin{lemma}[Compatibility for $Œº \,V$]
    If $A‚ÜíB,Œì \models^{ùí±} V : A ‚Üí B$,
    then $Œì \models^{ùí±} Œº \,V : A ‚Üí B$.
  \end{lemma}
  \begin{proof}
    Let $œÉ$ be a substitution.
    We need to show that \\
    $\mathcal{G}(Œì)(œÉ) ‚ä¢·µí ùí±(A ‚Üí B)(Œº\,V')$
    where $V' = \mathsf{ext}(œÉ)(V)$. \\
    We proceed by L\"ob induction, so we may assume \\
    $\mathop{‚ñ∑·µí} ùí±(A ‚Üí B)(Œº\,V')$ \qquad\qquad (IH)  \\
    From the premise of this lemma we have \\
    $\mathcal{G}(A‚ÜíB, Œì)(œÉ') ‚ä¢·µí ùí±(A ‚Üí B, œÉ'(V))$ 
    where $œÉ' = (Œº\,V',œÉ)$, \\
    and therefore \\
    $\mathcal{G}(Œì)(œÉ) ‚ä¢·µí ùí±(A‚ÜíB)(Œº\,V') ‚áí ùí±(A ‚Üí B)(œÉ'(V))$. \\
    Together with (IH), we have \\
    $\mathcal{G}(Œì)(œÉ) ‚ä¢·µí \mathop{‚ñ∑·µí} ùí±(A ‚Üí B)(œÉ'(V))$\\
    which is equivalent to our goal.
  \end{proof}
}
%===============================================================================
\frame{
  \frametitle{Bind Lemma}

  Many of the compatibility lemmas involve terms that have subterms.
  For example, the term $\suc{M}$ has subterm $M$.
  We'll know that $‚Ñ∞(‚Ñï)(M)$ and want to show $‚Ñ∞(‚Ñï)(\suc{M})$.
  From $‚Ñ∞(‚Ñï)(M)$ we can deduce that either $M$ diverges or
  $M \longrightarrow^{*} V$ where $ùí±(‚Ñï)(V)$ for some $V$.
  If $M$ diverges, so does $\suc{M}$. If $M$ reduces to $V$,
  then to prove $‚Ñ∞(‚Ñï)(\suc{M})$ it suffices to prove $‚Ñ∞(‚Ñï)(\suc{V})$.

  Generalizing this reasoning to any frame $F$ with subterm $M$
  gives us the following Bind lemma.

  \begin{lemma}[Bind]
    If $ùí´ ‚ä¢·µí ‚Ñ∞(B)(M)$ \\
    and $ùí´ ‚ä¢·µí ‚àÄ·µí V, M \longrightarrow^{*} V ‚áí·µí ùí±(B)(V) ‚áí·µí ‚Ñ∞(A)(F‚¶â V ‚¶ä)$ \\
    then $ùí´ ‚ä¢·µí ‚Ñ∞(A)(F ‚¶â M ‚¶ä)$.
  \end{lemma}

}
%===============================================================================
\frame{
  \frametitle{Compatibility Lemmas, continued}
  \small  
  \begin{lemma}
    If $ùí±(A{‚Üí}B)(V)$ and $ùí±(A)(W)$,
    then $‚Ñ∞(B)(V \app W)$.
  \end{lemma}
  \begin{proof}
    We proceed by L\"ob induction, so we may assume \\
    $‚àÄ·µí V W, ‚ñ∑·µí ùí±(A{‚Üí}B)(V) \AND ‚ñ∑·µí ùí±(A)(W) ‚áí·µí ‚ñ∑·µí ‚Ñ∞(B)(V \app W)$.
    From $ùí±(A{‚Üí}B)(V)$ we know that either $V=ŒªN$ or $V=Œº\,V'$.\\
    Suppose $V=ŒªN$. We have progress because $(ŒªN) W \longrightarrow N[W]$.
    We have preservation because $ùí±(A{‚Üí}B)(ŒªN)$ with premise $ùí±(A)(W)$
    tells us that $‚ñ∑·µí ‚Ñ∞(B)(N[W])$. \\
    Suppose $V=Œº\,V'$. We have progress:
    $(Œº\,V') W \longrightarrow V'[Œº\,V']\,W$. \\
    For preservation we need to show $‚ñ∑·µí ‚Ñ∞(B)(V'[Œº\,V'] \, W)$. \\
    From $ùí±(A{‚Üí}B)(Œº\,V')$ we have $‚ñ∑·µí ùí±(A{‚Üí}B)(V'[Œº\,V'])$
    and from $ùí±(A)(W)$ we have $‚ñ∑·µí ùí±(A)(W)$. So the induction hypothesis
    gives us $‚ñ∑·µí ‚Ñ∞(B)(V'[Œº\,V'] \, W)$.
  \end{proof}
}
%===============================================================================
\frame{
  \frametitle{Compatibility Lemmas, continued}
  
  \begin{lemma}[Compatibility for application]
    If $Œì \models L : A ‚Üí B$ and $Œì ‚äß M : A$,
    then $Œì \models L \app M : B$.
  \end{lemma}
  \begin{proof}
    Let $œÉ$ be a substitution. We need to prove that\\
    $\mathcal{G}(Œì)(œÉ) ‚ä¢·µí ‚Ñ∞(B)(œÉ(L) \app œÉ(M))$.\\
    We apply the Bind Lemma to $œÉ(L)$ and $œÉ(M)$ to obtain
    $œÉ(L) \longrightarrow^{*} V$, $œÉ(M) \longrightarrow^{*} W$,
    $ùí±(A{‚Üí}B)(V)$, $ùí±(A)(W)$, and
    it remains to prove $‚Ñ∞(B)(V \app W)$,
    which we obtain by the previous lemma.
  \end{proof}
}  
%===============================================================================
\frame{
  \frametitle{Recipe: $‚Ñ∞(A)(M)$ implies Type Safety}

  \begin{lemma}[Multi-step Preservation]
    If $M \longrightarrow^{*} N$ and $‚Ñ∞(A)(M)$,
    then $‚Ñ∞(A)(N)$.
  \end{lemma}
  \begin{proof}
    Proceed by induction on the reduction sequence,
    using the preservation part of $‚Ñ∞$ at each step.
  \end{proof}
  
  \begin{theorem}[Type Safety]
    If $\,‚àÖ ‚ä¢ M : A$ and $M \longrightarrow^{*} N$, \\
    then $N$ is a value or $N \longrightarrow N'$ for some $N'$.
  \end{theorem}
  \begin{proof}
    Apply the Fundamental Lemma to obtain $‚Ñ∞(A)(M)$.
    Then by Multi-step Preservation, we have $‚Ñ∞(A)(N)$.
    We conclude using the progress part of $‚Ñ∞(A)(N)$.
  \end{proof}
}  
%===============================================================================
\frame{
  \frametitle{Conclusion}

\begin{itemize}
\item Logical Relations Recipe:\\
  Define $ùí±(A)(V)$ and $‚Ñ∞(A)(M)$.\\
  Extend $ùí±$ and $‚Ñ∞$ to open terms.\\
  Prove the Fundamental Lemma. \\
  Prove that $‚Ñ∞$ implies your theorem.
\item A Step-Indexed Logic:\\
  Enables the definition of recursive predicates ($ùí±$ and $‚Ñ∞$)
  on full-featured programming languages. \\
  Hides the bookkeeping of the step indexing.\\
  Automates the proofs of monotonicity of $ùí±$ and $‚Ñ∞$.
\end{itemize}
}
%===============================================================================
\end{document}
